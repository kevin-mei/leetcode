大顶堆： 每个节点的值都大于其左右孩子节点的值；

大顶堆构建完毕后，根节点的值一定是最大的，然后把根节点和最后一个元素（也就是最后一个结点）
交换位置，那么末尾元素此时就是最大元素了。

如果需要从小到大排序，则用大顶堆，因为交换后，最大的结点就到了末尾；


这就是堆排序

再理清一下步骤：
1. 先n个元素的无序序列，构建大顶堆
2. 将根节点与最后一个元素交换为值。将最大的元素沉到数组末端
3. 交换过后可能不再满足大顶堆的条件，所以需要将剩下的n-1个元素重新构建成大顶堆
4. 重复第二步，第三步直到整个数组排序完成



int a[6] = {7,3,8,5,1,2}

先要找到最后一个非叶子节点，数组的长度为6，那么最后一个非叶子节点就是：长度/2-1,
也就是6/2-1=2，然后下一步就是比较该节点的值，和它的子树值，如果该节点小于其左\右
子树的值就交换；

a[i]>=a[2*i+1]  a[i]>=a[2*i+2]

```cpp
void Swap(int *heap, int len);        /* 交换根节点和数组末尾元素的值 */
void BuildMaxHeap(int *heap, int len);/* 构建大顶堆 */
```

```cpp
/* Function: 构建大顶堆 */
void BuildMaxHeap(int *heap, int len)
{
    int i;
    int temp;

    for (i = len/2-1; i >= 0; i--)
    {
        if ((2*i+1) < len && heap[i] < heap[2*i+1])    /* 根节点小于左子树 */
        {
            temp = heap[i];
            heap[i] = heap[2*i+1];
            heap[2*i+1] = temp;
            /* 检查交换后的左子树是否满足大顶堆性质 如果不满足 则重新调整子树结构 */
            if ((2*(2*i+1)+1 < len && heap[2*i+1] < heap[2*(2*i+1)+1]) || (2*(2*i+1)+2 < len && heap[2*i+1] < heap[2*(2*i+1)+2]))
            {
                BuildMaxHeap(heap, len);
            }
        }
        if ((2*i+2) < len && heap[i] < heap[2*i+2])    /* 根节点小于右子树 */
        {
            temp = heap[i];
            heap[i] = heap[2*i+2];
            heap[2*i+2] = temp;
            /* 检查交换后的右子树是否满足大顶堆性质 如果不满足 则重新调整子树结构 */
            if ((2*(2*i+2)+1 < len && heap[2*i+2] < heap[2*(2*i+2)+1]) || (2*(2*i+2)+2 < len && heap[2*i+2] < heap[2*(2*i+2)+2]))
            {
                BuildMaxHeap(heap, len);
            }
        }
    }
}
```