1. 虚函数的实现方式?
   通过虚函数表和虚函数表指针实现， 虚函数表一般放在程序的只读段，windows放在常量区，linux放在只读数据段中(rodata)； 虚函数本身位于代码段（.text）; 虚函数表指针是带有虚函数的类实例化（执行构造函数时）时，会初始化虚函数表指针，虚函数表指针和类的实例对象相关；

   **基类的析构函数**一般要写成虚函数，当声明的是父类对象，但是new的是子类对象，这时候delete是，就会指向子类的析构函数，而子类的析构函数有自动调用基类的析构函数，这样整个子类对象就会完全被释放；

   如果析构函数没声明成虚函数，那这个对象delete时，就会造成内存泄露；

   构造函数不能定义为虚函数； 再构造函数中可以调用虚函数，不过此时正在调用的正在构造的类中的虚函数，而子类的虚函数还没有构造好；

   构造时：先父类，在子类
   删除时：先子类，再父类；

2. 类对象的存储空间：是非静态成员的数据类型大小之和，编译器加入的额外成员变量（如指向虚函数表的指针）。

3. 内联函数和宏定义的区别
   内联函数和普通函数相比，可以加快程序的运行速度，因为不需要中断调用（不用创建新的函数堆栈，减少保存期存器，返回时恢复，拷贝实参等）
   lambda表达式，可以看做未命名的内联函数，[]可以捕获局部变量列表，为空表示不需要使用所在函数的局部变量
   `auto compare=[](pair<int, int> &a, pair<int, int> &b){ return a.first < b.first; };`
    - 内联函数在编译时展开，宏在预编译时展开
    - 内联函数直接嵌入到目标代码中，宏是简单的做文本替换
    - 内联函数有类型检测、语法判断等功能，而宏没有
    - 内联函数是函数，宏不是
    - 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
    - 内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高；
4. 如何用代码判断大小端存储
   可以使用强制类型转换，
   ```c
   int a = 0x1234; char c = (char)(a);
   if(c == 0x12) // 说明低地址存放的高地址的数据  大端存储
   else 
    //小端存储
   ```