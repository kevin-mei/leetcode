/*
 * @lc app=leetcode.cn id=1478 lang=cpp
 *
 * [1478] 安排邮筒
 */
 // 给定一个房屋数组house 和一个整数k，其中house[i]是第i栋房子在一条街上的位置，现需要在这条街上安排k个邮筒
 // 请返回每栋房子与它最近的邮筒之间的距离的 最小 之和
 // 答案保证再int范围之类

 //例1 houses [1,4,8,10,20] k=3  输出 5
 // 解释，将邮筒分别放在位置3,9,20处， 每个房子到最近的邮筒的距离和 3-1 + 4-3 + 9-8 + 10-8 + 20-20 = 5
 //例2 houses [2,3,5,12,18] k=2 输出 9
 // 解释，将邮筒分别放在位置3,14处， 每个房子到最近的邮筒的距离和 3-2 + 0 + 5-3 + 14-12 + 18-14 = 3+6 =9
 //例3 houses [1,4,6,7] k=1 输出 8 
 // 解释，将邮筒放在位置5   4+1+1+2
 //例4 houses = [3,6,14,10] k=4  输出 0
 // 解释，每个邮筒放一个

// 看到这里明白了，
// 如果没有邮筒，有屋，距离为int_max ，输入不合理
// 如果一个邮筒，1个屋，距离为0 
// 如果一个邮筒，两个屋，放在两屋之间哪个位置都行，距离为两屋的距离
// 如果一个邮筒，3个屋，放在中间那个屋，距离为两个端点屋的距离之和
// 如果一个邮筒，4个屋，放在所有屋的中间点，距离为  可以简化为，两个端点的屋，放在哪个位置都行， 中间还有两个屋，放在他们两个屋的中间哪个点都行，相当于 两个端点的距离加内部两个屋的距离
// 如果一个邮筒，5个屋，放在最中间的那个屋，简化为上一个问题
// 如果一个邮筒，6个屋，放在最中间两个屋之间随便一个点，距离为每两对屋的距离之差

// 也就是，一个邮筒，偶数对屋，放在最中间, 奇数对屋，也放在最中间


// 如果两个邮筒，类似例1，例2， 考虑的是怎么划分房子群，使得一群房子一个邮筒 ，区分子序列

// 状态转移方程  n 和 n-1的关系
// 这里要思考下，n代表什么，状态函数的定义是啥
// 动态规划 一定会有重叠子问题，我们刚才分析到的，1个筒多个屋，就是重叠子问题，可以依次拆解为1个筒，两个屋或1个筒，1个屋问题


// cost(l,r)表示给排好序的houses[l]到houses[r]的房子安排一个邮筒，可以得到的最小的距离总和 cost(l,r) = 邮筒选房子的中位数（偶数取中间两个数的平均值）
// 集中点 cost 到底是不是一个重叠子问题？有递推式，重叠子问题，妥妥的呀
// l,r 确定的话，那么安排一个邮筒，它的值是确认的，为啥会有一个最小距离总和呢?

// 这个是有递推公式的 因为只能安排一个邮筒，cost[left][right] 
// cost[left][right] = cost[left + 1][right - 1] + houses[right] - houses[left];

// cost[left,right]的求解
// 也就是，一个邮筒安排在[l,r]之间，[l,r]之间的屋有个数为n
// 偶数对屋，放在最中间, 距离为每两对屋的距离之差  
// 奇数对屋，也放在最中间,距离为除去最中间的屋，然后每两对屋的距离之差
// 或者已知cost[left + 1][right - 1]， 得到这个递推公式 
// cost[left][right] = cost[left + 1][right - 1] + houses[right] - houses[left];
// 当 left + 1 ==  right - 1时，cost为0，即 cost[1][1] = 0
// 我现在不知道我会用到那个，那就所有的cost都求出来
// 我们从哪里开始循环 为啥从尾部开始循环，而不是从头开始循环？
// 从第一个0位置开始算 left先确定，cost[left + 1][anypos] 这个界肯定是没有算过的, 所以你的递推式就决定了left要从大到小算，先算出大的，递推式才有用，right从小往大算

// 我们用f[i][j]标识给前i栋房子安排j个邮筒，(从1开始编号)的最小距离总和，我们可以枚举第j个邮筒负责的房子的起始编号，从i0+1到i结束
// f[i][j] = min{f[k][j-1]+cost(k+1,i)}  以及边界条件 f[i][1] = cost(0,i)
// f[k][j-1] 这个意思是前k个屋子的安排j-1个邮筒， k+1到i安排1个邮筒， k 可以取[0,i]之间的数
// f[i][j] = min{f[0][j-1]+cost(1,i)，f[1][j-1]+cost(2,i）, ...，f[k][j-1]+cost(k+1,i)}  k 取[0,i-1], 边界条件 f[i][1] = cost(0,i)



// @lc code=start
//#include "pch.h"
class Solution {
public:
    int minDistance(vector<int>& houses, int m) {
        // 先给房子排序
        int n = houses.size();
        std::sort(houses.begin(), houses.end());

        vector<vector<int>> cost(n, vector<int>(n, 0)); // 新建一个二维数组，大小为n*n, n为房子的数量,初始化值均为0

        //cost[l,r] 表示给排好序的房子houses[l]到houses[r]安排一个邮筒
        for (int left = n - 2; left >= 0; --left) {
            // 从倒数第2个算 left先确定，然后right递增到n-1，最后一个
            for (int right = left + 1; right < n; ++right) {
                cost[left][right] = cost[left + 1][right - 1] + houses[right] - houses[left];
            }
        }

        // 这里直接初始化为 INT_MAX会出现int溢出,有大佬用1e8,2e9之类的数作为最大值
        // 1E8代表数字是100000000,1*10^8 2e9 = 2*10^9
        // INT_MAX = 2^31-1 = 2147483647  2后面有9位数
        vector<vector<int>> f(n, vector<int>(m + 1, 2e9)); // 新建一个二维数组，大小为n，m+1,因为最后要访问到f[n-1][m]
        for (int i = 0; i < n; ++i) {
            f[i][1] = cost[0][i]; // i [0, n-1]
            for (int j = 2; j <= m && j <= i + 1; ++j)  //j [2, m] 因为递推式j-1，所以j从小往大遍历
            {   
                for (int k = 0; k < i; ++k) 
                {
                    // f[i][j] 的初始值要INT_MAX 基本上是最大的了  f[k][j - 1] + cost[k + 1][i]只能小
                    // k++之后，相当于两个相邻的 f[k-1][j - 1] + cost[k ][i] 和 f[k][j - 1] + cost[k + 1][i]，求最小值
                    // 最后完成整个集合的最小值{f[0][j-1]+cost(1,i)，f[1][j-1]+cost(2,i）, ...，f[k][j-1]+cost(k+1,i)} 
                    f[i][j] = min(f[i][j], f[k][j - 1] + cost[k + 1][i]); 
                }
            }
            // [n-1][m]
        }
        return f[n-1][m];
    }
};
// @lc code=end

